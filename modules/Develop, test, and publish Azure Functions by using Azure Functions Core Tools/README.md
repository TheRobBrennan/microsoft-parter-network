[Develop, test, and publish Azure Functions by using Azure Functions Core Tools](https://docs.microsoft.com/en-us/learn/modules/develop-test-deploy-azure-functions-with-core-tools/) (~20 mins)

Use the Azure Functions Core Tools to create and run functions on a development computer and publish them to Azure.

By the end of this module, you will be able to use the Azure Functions Core Tools to:

- Create new functions projects and functions
- Run and test functions locally
- Publish functions to Azure

Prerequisites:

- Beginner-level Azure Functions development experience
- Familiarity with basic command line usage

# Notes and key takeaways

## Introduction

The Azure Functions Core Tools are command-line utilities that enable you to develop and run functions locally and publish them to Azure.

Suppose you're a developer for a car dealership chain. The sales people are always looking for ways to modernize their workflow. Your manager has decided to build a set of applications backed by Azure Functions. The first service he'd like built involves loan interest calculations. He's asked you to look into creating functions that can be called over the web to run loan interest calculations. You've decided to start by learning how to use the Azure Functions Core Tools to build and publish a function.

In this module, you'll use the Azure Functions Core Tools from the command line to create a new local functions project and function. You'll modify the starter code generated by the Core Tools to run a simple interest calculation and run the function locally to test it. When it's ready, you'll use the Azure CLI to create a function app in Azure, publish your function, then invoke it over the web.

By the end of this module, you'll be able to use the Core Tools from the command line to create and run functions locally and publish them to Azure.

This module's exercise can be completed in the browser, and doesn't require an Azure subscription or local development environment.

## Create and run Azure Functions locally by using the Core Tools

Here, you'll learn how to use the Core Tools to create and run functions locally.

### What are the Azure Functions Core Tools?

The Core Tools feature a variety of functions-related capabilities, but their primary purpose is to:

- Generate the files and folders you need to develop functions on your local computer
- Run your functions locally so you can test and debug them
- Publish your functions to Azure

The Core Tools are packaged as a single command-line utility named `func`. If you run `func` from the command line without any additional commands, it will display version information and a usage guide.

The Core Tools are standalone utilities, not an extension of a larger integrated development environment or tool. You can accomplish the above tasks with nothing but the command line and the Core Tools, and use any text editor you like to write code and modify configuration. In practice, you'll also need the Azure CLI or Azure PowerShell to log in to Azure and perform other management tasks.

Other Functions development tools, such as the Functions-related features in Visual Studio and the Azure Functions extension for Visual Studio Code, are built on top of the Core Tools.

#### Core Tools versions

In other documentation, you may see references to two different versions of the Core Tools: versions 1.x and 2.x. We recommend using the newest available revision of version 2.x, as it offers the best support for most scenarios and it can be installed on Windows, macOS and Linux computers.

We'll be discussing and using version 2.x in this tutorial, but you won't need to install anything on your own computer to complete it. We'll use the in-browser Cloud Shell environment for development, and the Core Tools are already installed there, along with the Azure CLI and a code editor.

#### Local development vs. Azure portal development

The Azure portal features a functions editor experience, but in most cases it does not support working with functions that were developed locally.

**Once you start using a local development workflow based on the Core Tools, don't expect to be able to use the portal to make changes to your functions.**

Let's start with the Core Tools by taking a closer look at how to create functions and run them locally. We'll look at how to publish to Azure later on in this tutorial.

### Creating functions locally

#### Function apps and functions projects

Every function published to Azure belongs to a function app: a collection of functions that are published together into the same environment. All of the functions in an app share a common set of configuration values, and must all be built for the same language runtime. Each function app is an Azure resource that can be configured and managed independently.

When you develop functions locally, you work within a functions project: a folder that contains the code and configuration files that define your functions. A functions project on your computer is equivalent to a function app in Azure, and can contain multiple functions that use the same language runtime.

To get started developing, you need to create a functions project folder that's organized correctly. Every new function you add to the project requires additional code and configuration that must be complete and correctly structured, or your functions will not be able to run. If you wanted to, you could become familiar with the names and contents of the files needed in a functions project folder and create them yourself, but doing so would be time-consuming and error-prone.

With the Azure Functions Core Tools, you'll never need to do this! You can use the Core Tools to generate function projects and functions from scratch.

#### Creating a new functions project with func init

To create a new functions project, run `func init` on the command line:

![https://docs.microsoft.com/en-us/learn/modules/develop-test-deploy-azure-functions-with-core-tools/media/2-func-init-output.png](https://docs.microsoft.com/en-us/learn/modules/develop-test-deploy-azure-functions-with-core-tools/media/2-func-init-output.png)

`func init` will ask you which language runtime you'd like to use for the app and tailor the project folder's contents appropriately.

When you create a new functions project, the files included in the project folder depend on the language runtime you select. Regardless of the runtime you choose, the two most critical project files are always present:

- host.json stores runtime configuration values, such as logging options, for the function app. The settings stored in this file are used both when running functions locally and in Azure.
- local.settings.json stores configuration values that only apply to the function app when it is run locally with the Core Tools. This file contains two kinds of settings: local runtime settings, used to configure the local functions runtime itself, and custom application settings, which you can add and configure based on your app's needs and can be accessed and used by all the functions in the app.

Functions projects that `func init` generates don't have any functions in them. Let's find out how to add one.

#### Creating a new function with func new

Each individual function in a project requires code and configuration to define its behavior. Running func new in a functions project folder will create a new function and all the files you need to get started developing.

![https://docs.microsoft.com/en-us/learn/modules/develop-test-deploy-azure-functions-with-core-tools/media/2-func-new-output.png](https://docs.microsoft.com/en-us/learn/modules/develop-test-deploy-azure-functions-with-core-tools/media/2-func-new-output.png)

After asking you which kind of function trigger you want to use and what you'd like to name your function, func new will generate a complete, publish-ready starter implementation in your function project's chosen language. The starter code illustrates how to use the type of trigger you selected and is there to help you get started quickly: just replace the body of the function with your own implementation, and you're ready to build, run, test and publish.

In the next part of this tutorial, we'll use `func new` to create an HTTP-triggered function and modify the starter implementation to perform a simple interest calculation.

### Running functions locally

Functions aren't programs that can be run on their own: they must be hosted by the functions host. The host is what powers everything outside of your function code: it loads configuration, listens for triggers and HTTP requests, starts the worker process for the language your functions are written in, writes log output and more. In Azure, function apps run the function host automatically when they start.

You can use the Core Tools to run your own instance of the functions host and try out your functions locally before you publish them. By running your functions before publishing them, you can make sure your configuration and code loads correctly and test out your functions by making real HTTP calls to them without the need for Azure resources.

To start the functions host locally, run `func start` from a functions project folder. At the end of the output, the Core Tools will display local URLs you can use to call of each of your functions. While the host is running, you can use any tools or libraries that make HTTP calls, like curl, to interact with your functions. The Core Tools will write any log output produced by the host to the terminal in real time.

![https://docs.microsoft.com/en-us/learn/modules/develop-test-deploy-azure-functions-with-core-tools/media/2-func-start-output.png](https://docs.microsoft.com/en-us/learn/modules/develop-test-deploy-azure-functions-with-core-tools/media/2-func-start-output.png)

## Exercise - Create a function locally by using the Core Tools

The Core Tools give you a way to get started developing functions locally by creating the files and folders you need and letting you run your functions on your own computer.

You've decided to start your work with Azure Functions by locally developing a function that computes simple interest. Eventually you'll work your way up to more complex functions that work together and call other services and databases, but using the Core Tools to build a function that performs a basic loan calculation is a good start. You also want to try calling your function on your own computer before publishing it to Azure.

In this exercise, we'll create and run our first function from the Cloud Shell command line using the Core Tools.

### Create a local Azure Functions project

In this exercise, we'll use the in-browser Cloud Shell to develop our function. The Cloud Shell system has the Core Tools and Azure CLI preinstalled, as well as an editor we'll use to write code. Make sure to activate the sandbox above before proceeding.

```sh
Requesting a Cloud Shell.Succeeded.
Connecting terminal...

Welcome to Azure Cloud Shell

Type "az" to use Azure CLI
Type "help" to learn about Cloud Shell

# In the Cloud Shell pane on the right, create a new directory called loan-wizard and cd into it:
rob@Azure:~$ mkdir ~/loan-wizard
rob@Azure:~$ cd ~/loan-wizard
rob@Azure:~/loan-wizard$ func init
Select a number for worker runtime:
1. dotnet
2. node
3. python
4. powershell
Choose option: 2
node
Select a number for language:
1. javascript
2. typescript
Choose option: 1
javascript
Writing package.json
Writing .gitignore
Writing host.json
Writing local.settings.json
Writing /home/rob/loan-wizard/.vscode/extensions.json
rob@Azure:~/loan-wizard$
```

### Create an HTTP-triggered function

Let's create our function!

```sh
# In the Cloud Shell pane, run func new to start the function creation wizard
#   Note that we're running func new from inside the loan-wizard project folder we just created, which is important.
rob@Azure:~/loan-wizard$ func new
Select a number for template:
1. Azure Blob Storage trigger
2. Azure Cosmos DB trigger
3. Durable Functions activity
4. Durable Functions HTTP starter
5. Durable Functions orchestrator
6. Azure Event Grid trigger
7. Azure Event Hub trigger
8. HTTP trigger
9. IoT Hub (Event Hub)
10. Azure Queue Storage trigger
11. SendGrid
12. Azure Service Bus Queue trigger
13. Azure Service Bus Topic trigger
14. SignalR negotiate HTTP trigger
15. Timer trigger
Choose option: 8
HTTP trigger
Function name: [HttpTrigger] simple-interest
Writing /home/rob/loan-wizard/simple-interest/index.js
Writing /home/rob/loan-wizard/simple-interest/function.json
The function "simple-interest" was created successfully from the "HTTP trigger" template.
rob@Azure:~/loan-wizard$

# Open the Cloud Shell editor
rob@Azure:~/loan-wizard$ code .
```

The wizard has created a new folder in our functions project called `simple-interest` and generated default `index.js` and `function.json` files in it. If you like, take a moment now to explore the project files in the editor.

### Implement the simple-interest function

The function implementation that the Core Tools created for us in `index.js` looks for an input called `name` in the query string or the body of the inbound HTTP request and returns the string `Hello {name}`. This is a good illustration of how to use an HTTP trigger, but we want to replace it with our simple interest implementation.

```sh
# Open the Cloud Shell editor
rob@Azure:~/loan-wizard$ code .

# In the code editor's Files pane, expand the simple-interest folder and select index.js to open it in the editor.
```

Replace the full contents of `index.js` with the following code:

```js
module.exports = async function (context, req) {
  // Try to grab principal, rate and term from the query string and
  // parse them as numbers
  const principal = parseFloat(req.query.principal)
  const rate = parseFloat(req.query.rate)
  const term = parseFloat(req.query.term)

  if ([principal, rate, term].some(isNaN)) {
    // If any empty or non-numeric values, return a 400 response with an
    // error message
    context.res = {
      status: 400,
      body: "Please supply principal, rate and term in the query string",
    }
  } else {
    // Otherwise set the response body to the product of the three values
    context.res = { body: principal * rate * term }
  }
}
```

This implementation looks for parameters named `principal`, `rate` and `term` in the query string of the HTTP request and returns the result of the simple interest calculation.

Save the file with `Ctrl+S` and close the editor with `Ctrl+Q`

### Run the function locally

To run our new function locally and try it out, we'll use `func start` to start the functions runtime.

Run `func start` to start the local functions host. As with `func new`, your shell should still be in the `loan-wizard` directory:

```sh
rob@Azure:~/loan-wizard$ func start

                  %%%%%%
                 %%%%%%
            @   %%%%%%    @
          @@   %%%%%%      @@
       @@@    %%%%%%%%%%%    @@@
     @@      %%%%%%%%%%        @@
       @@         %%%%       @@
         @@      %%%       @@
           @@    %%      @@
                %%
                %

Azure Functions Core Tools (2.7.2184 Commit hash: 5afacc827c2848e4debc23bb96604f1ffce09cc7)
Function Runtime Version: 2.0.12961.0
[7/1/20 11:43:23 PM] FUNCTIONS_WORKER_RUNTIME set to node. Skipping WorkerConfig for language:java
[7/1/20 11:43:23 PM] FUNCTIONS_WORKER_RUNTIME set to node. Skipping WorkerConfig for language:powershell
[7/1/20 11:43:23 PM] FUNCTIONS_WORKER_RUNTIME set to node. Skipping WorkerConfig for language:python
[7/1/20 11:43:23 PM] Building host: startup suppressed: 'False', configuration suppressed: 'False', startup operation id: '4a1efafe-f210-46cc-bef6-fcbfa79286d1'
[7/1/20 11:43:24 PM] Reading host configuration file '/home/rob/loan-wizard/host.json'
[7/1/20 11:43:24 PM] Host configuration file read:
[7/1/20 11:43:24 PM] {
[7/1/20 11:43:24 PM]   "version": "2.0",
[7/1/20 11:43:24 PM]   "extensionBundle": {
[7/1/20 11:43:24 PM]     "id": "Microsoft.Azure.Functions.ExtensionBundle",
[7/1/20 11:43:24 PM]     "version": "[1.*, 2.0.0)"
[7/1/20 11:43:24 PM]   }
[7/1/20 11:43:24 PM] }
[7/1/20 11:43:24 PM] Reading functions metadata
[7/1/20 11:43:24 PM] 1 functions found
[7/1/20 11:43:24 PM] Looking for extension bundle Microsoft.Azure.Functions.ExtensionBundle at /tmp/Functions/ExtensionBundles/Microsoft.Azure.Functions.ExtensionBundle
[7/1/20 11:43:24 PM] Found a matching extension bundle at /tmp/Functions/ExtensionBundles/Microsoft.Azure.Functions.ExtensionBundle/1.3.0
[7/1/20 11:43:24 PM] Fetching information on versions of extension bundle Microsoft.Azure.Functions.ExtensionBundle available on https://functionscdn.azureedge.net/public/ExtensionBundles/Microsoft.Azure.Functions.ExtensionBundle/index.json
[7/1/20 11:43:24 PM] Skipping bundle download since it already exists at path /tmp/Functions/ExtensionBundles/Microsoft.Azure.Functions.ExtensionBundle/1.3.0
[7/1/20 11:43:24 PM] Loading Extention bundle from /tmp/Functions/ExtensionBundles/Microsoft.Azure.Functions.ExtensionBundle/1.3.0
[7/1/20 11:43:24 PM] Initializing Warmup Extension.
[7/1/20 11:43:24 PM] FUNCTIONS_WORKER_RUNTIME set to node. Skipping WorkerConfig for language:java
[7/1/20 11:43:24 PM] FUNCTIONS_WORKER_RUNTIME set to node. Skipping WorkerConfig for language:powershell
[7/1/20 11:43:24 PM] FUNCTIONS_WORKER_RUNTIME set to node. Skipping WorkerConfig for language:python
[7/1/20 11:43:24 PM] Initializing Host. OperationId: '4a1efafe-f210-46cc-bef6-fcbfa79286d1'.
[7/1/20 11:43:24 PM] Host initialization: ConsecutiveErrors=0, StartupCount=1, OperationId=4a1efafe-f210-46cc-bef6-fcbfa79286d1
[7/1/20 11:43:25 PM] LoggerFilterOptions
[7/1/20 11:43:25 PM] {
[7/1/20 11:43:25 PM]   "MinLevel": "None",
[7/1/20 11:43:25 PM]   "Rules": [
[7/1/20 11:43:25 PM]     {
[7/1/20 11:43:25 PM]       "ProviderName": null,
[7/1/20 11:43:25 PM]       "CategoryName": null,
[7/1/20 11:43:25 PM]       "LogLevel": null,
[7/1/20 11:43:25 PM]       "Filter": "<AddFilter>b__0"
[7/1/20 11:43:25 PM]     },
[7/1/20 11:43:25 PM]     {
[7/1/20 11:43:25 PM]       "ProviderName": "Microsoft.Azure.WebJobs.Script.WebHost.Diagnostics.SystemLoggerProvider",
[7/1/20 11:43:25 PM]       "CategoryName": null,
[7/1/20 11:43:25 PM]       "LogLevel": "None",
[7/1/20 11:43:25 PM]       "Filter": null
[7/1/20 11:43:25 PM]     },
[7/1/20 11:43:25 PM]     {
[7/1/20 11:43:25 PM]       "ProviderName": "Microsoft.Azure.WebJobs.Script.WebHost.Diagnostics.SystemLoggerProvider",
[7/1/20 11:43:25 PM]       "CategoryName": null,
[7/1/20 11:43:25 PM]       "LogLevel": null,
[7/1/20 11:43:25 PM]       "Filter": "<AddFilter>b__0"
[7/1/20 11:43:25 PM]     }
[7/1/20 11:43:25 PM]   ]
[7/1/20 11:43:25 PM] }
[7/1/20 11:43:25 PM] FunctionResultAggregatorOptions
[7/1/20 11:43:25 PM] {
[7/1/20 11:43:25 PM]   "BatchSize": 1000,
[7/1/20 11:43:25 PM]   "FlushTimeout": "00:00:30",
[7/1/20 11:43:25 PM]   "IsEnabled": true
[7/1/20 11:43:25 PM] }
[7/1/20 11:43:25 PM] SingletonOptions
[7/1/20 11:43:25 PM] {
[7/1/20 11:43:25 PM]   "LockPeriod": "00:00:15",
[7/1/20 11:43:25 PM]   "ListenerLockPeriod": "00:00:15",
[7/1/20 11:43:25 PM]   "LockAcquisitionTimeout": "10675199.02:48:05.4775807",
[7/1/20 11:43:25 PM]   "LockAcquisitionPollingInterval": "00:00:05",
[7/1/20 11:43:25 PM]   "ListenerLockRecoveryPollingInterval": "00:01:00"
[7/1/20 11:43:25 PM] }
[7/1/20 11:43:25 PM] HttpOptions
[7/1/20 11:43:25 PM] {
[7/1/20 11:43:25 PM]   "DynamicThrottlesEnabled": false,
[7/1/20 11:43:25 PM]   "MaxConcurrentRequests": -1,
[7/1/20 11:43:25 PM]   "MaxOutstandingRequests": -1,
[7/1/20 11:43:25 PM]   "RoutePrefix": "api"
[7/1/20 11:43:25 PM] }
[7/1/20 11:43:25 PM] Starting JobHost
[7/1/20 11:43:25 PM] Starting Host (HostId=cca59e848468f9c594bfqkh9q-254542, InstanceId=cee4f6e3-129e-4414-821c-f35885f0cc47, Version=2.0.12961.0, ProcessId=200, AppDomainId=1, InDebugMode=False, InDiagnosticMode=False, FunctionsExtensionVersion=(null))
[7/1/20 11:43:25 PM] Loading functions metadata
[7/1/20 11:43:25 PM] 1 functions loaded
[7/1/20 11:43:25 PM] Starting worker process:node  "/usr/lib/azure-functions-core-tools/workers/node/dist/src/nodejsWorker.js" --host 127.0.0.1 --port 42977 --workerId b3869e21-90fb-466f-b549-189ffdc8b272 --requestId ab96fd03-ace3-4f4c-85df-1d79ad8f5746 --grpcMaxMessageLength 134217728
[7/1/20 11:43:25 PM] node process with Id=229 started
[7/1/20 11:43:25 PM] Generating 1 job function(s)
[7/1/20 11:43:25 PM] Found the following functions:
[7/1/20 11:43:25 PM] Host.Functions.simple-interest
[7/1/20 11:43:25 PM]
[7/1/20 11:43:25 PM] Initializing function HTTP routes
[7/1/20 11:43:25 PM] Mapped function route 'api/simple-interest' [get,post] to 'simple-interest'
[7/1/20 11:43:25 PM]
[7/1/20 11:43:25 PM] Host initialized (361ms)
[7/1/20 11:43:25 PM] Host started (370ms)
[7/1/20 11:43:25 PM] Job host started
Hosting environment: Production
Content root path: /home/rob/loan-wizard
Now listening on: http://0.0.0.0:7071
Application started. Press Ctrl+C to shut down.

Http Functions:

        simple-interest: [GET,POST] http://localhost:7071/api/simple-interest

[7/1/20 11:43:25 PM] Worker b3869e21-90fb-466f-b549-189ffdc8b272 connecting on 127.0.0.1:42977
[7/1/20 11:43:30 PM] Host lock lease acquired by instance ID '000000000000000000000000E6D5841E'.

```

At the end of the output, you'll see a message that the simple-interest function is available at the URL http://localhost:7071/api/simple-interest. If you see an error message, use `Ctrl+C`to stop the host and make sure that the contents of your index.js file are the same as the sample above.

This localhost URL is not published to the web, it's only reachable from tools running in the Cloud Shell. We're going to use a command-line tool, `curl`, to interact with our function. To do that, we need to restart the Functions host as a background process so we can use the command line while it's running.

If you were using the Core Tools from your own computer, you probably wouldn't need to do this. You could use `curl` from a second terminal window, and the output produced by the Core Tools would be displayed in real time in the first window. In the Cloud Shell, we are limited to a single terminal, so this technique is necessary for this tutorial.

Press `Ctrl+C` to stop the Functions host.

Run the following command to start the Functions host silently in the background:

```sh
rob@Azure:~/loan-wizard$ func start &> ~/output.txt &
[1] 273
```

You can ignore the output of this command. The Functions host is now running exactly as before, but its output is being sent to the file ~/output.txt, and we can continue to use the command line while it's running.

Run this command to send an HTTP GET request to our locally-running function:

```sh
rob@Azure:~/loan-wizard$ curl "http://localhost:7071/api/simple-interest" -w "\n"
Please supply principal, rate and term in the query string
```

Invoke the function again, this time with values for the all of the query string parameters:

```sh
rob@Azure:~/loan-wizard$ curl "http://localhost:7071/api/simple-interest?principal=5000&rate=.035&term=36" -w "\n"
6300
```

This time, the output we receive is `6300`. Our function is working as expected!

Stop the background functions host with the `pkill` utility:

```sh
rob@Azure:~/loan-wizard$ pkill func
rob@Azure:~/loan-wizard$
[1]+  Done                    func start &> ~/output.txt
```

Press `Enter` a second time to see the confirmation that the host has stopped: [1]+ Done func start &> ~/output.txt.

View the host's log output in the code editor:

```sh
rob@Azure:~/loan-wizard$ code ~/output.txt
```

The top 90 lines or so of the file will be the same as when you ran `func start` the first time. After that, you'll see a set of log entries for each time you called the function with `curl`, each one looking like this:

```sh
[7/1/20 11:47:21 PM] Executing HTTP request: {
[7/1/20 11:47:21 PM]   "requestId": "3fb38284-d9a7-457c-8c91-9f95014edb15",
[7/1/20 11:47:21 PM]   "method": "GET",
[7/1/20 11:47:21 PM]   "uri": "/api/simple-interest"
[7/1/20 11:47:21 PM] }
[7/1/20 11:47:22 PM] Executing 'Functions.simple-interest' (Reason='This function was programmatically called via the host APIs.', Id=70265762-28b7-433a-8967-94fcb3246062)
[7/1/20 11:47:22 PM] Executed 'Functions.simple-interest' (Succeeded, Id=70265762-28b7-433a-8967-94fcb3246062)
[7/1/20 11:47:22 PM] Executed HTTP request: {
[7/1/20 11:47:22 PM]   "requestId": "3fb38284-d9a7-457c-8c91-9f95014edb15",
[7/1/20 11:47:22 PM]   "method": "GET",
[7/1/20 11:47:22 PM]   "uri": "/api/simple-interest",
[7/1/20 11:47:22 PM]   "identities": [
[7/1/20 11:47:22 PM]     {
[7/1/20 11:47:22 PM]       "type": "WebJobsAuthLevel",
[7/1/20 11:47:22 PM]       "level": "Admin"
[7/1/20 11:47:22 PM]     }
[7/1/20 11:47:22 PM]   ],
[7/1/20 11:47:22 PM]   "status": 400,
[7/1/20 11:47:22 PM]   "duration": 1135
[7/1/20 11:47:22 PM] }
[7/1/20 11:47:52 PM] Executing HTTP request: {
[7/1/20 11:47:52 PM]   "requestId": "76f88a72-9d8e-4205-aac1-516ddf8147e6",
[7/1/20 11:47:52 PM]   "method": "GET",
[7/1/20 11:47:52 PM]   "uri": "/api/simple-interest"
[7/1/20 11:47:52 PM] }
[7/1/20 11:47:52 PM] Executing 'Functions.simple-interest' (Reason='This function was programmatically called via the host APIs.', Id=f2a73182-3afb-46a6-ab6e-7188d68158f0)
[7/1/20 11:47:52 PM] Executed 'Functions.simple-interest' (Succeeded, Id=f2a73182-3afb-46a6-ab6e-7188d68158f0)
[7/1/20 11:47:52 PM] Executed HTTP request: {
[7/1/20 11:47:52 PM]   "requestId": "76f88a72-9d8e-4205-aac1-516ddf8147e6",
[7/1/20 11:47:52 PM]   "method": "GET",
[7/1/20 11:47:52 PM]   "uri": "/api/simple-interest",
[7/1/20 11:47:52 PM]   "identities": [
[7/1/20 11:47:52 PM]     {
[7/1/20 11:47:52 PM]       "type": "WebJobsAuthLevel",
[7/1/20 11:47:52 PM]       "level": "Admin"
[7/1/20 11:47:52 PM]     }
[7/1/20 11:47:52 PM]   ],
[7/1/20 11:47:52 PM]   "status": 200,
[7/1/20 11:47:52 PM]   "duration": 24
[7/1/20 11:47:52 PM] }
```

Close the editor with `Ctrl+Q`

## Publish a function to Azure by using the Core Tools

You can use the Core Tools to publish your functions to Azure.

Now that you've built and tested your simple interest function, you'd like to get it published to Azure. It would be great to see it up and running on the web and provide the URL to your colleagues so they can see how it can be called from anywhere.

In this unit, you'll see how to create a function app in Azure and use the Core Tools to publish your functions project to it.

### Creating a function app

**Before you can use the Core Tools to publish a project, you need to create a function app in Azure.**

This is not a capability of the Core Tools: creating function apps is one of the responsibilities of the Azure management tools, which include the Azure portal, Azure CLI and Azure PowerShell. In the next exercise, we'll use the Azure CLI's `az functionapp create` command to create a function app to which we can publish our code.

Within the scope of this tutorial, the most important option to consider when creating a function app is the language runtime. **A given function app only supports a single language runtime.** If you already have a local functions project you want to publish, make sure to create the function app with the same language runtime. If you try to deploy a project to an app with a different runtime, publishing will halt with an error.

### Publishing to Azure

To publish a functions project to Azure, run `func azure functionapp publish <app_name>` from the functions project folder. <app_name> is the name of the target function app in Azure, not the name of your project folder, which can be different.

![https://docs.microsoft.com/en-us/learn/modules/develop-test-deploy-azure-functions-with-core-tools/media/4-publish.png](https://docs.microsoft.com/en-us/learn/modules/develop-test-deploy-azure-functions-with-core-tools/media/4-publish.png)

The Core Tools don't ask you to sign in to Azure. Instead, they access your subscriptions and resources by loading your session information from the Azure CLI or Azure PowerShell. If you don't have an active session in one of those tools, publishing will fail. It's possible to publish from the Core Tools without the Azure CLI or Azure PowerShell, but it's much easier if you do have them, and we recommend you install one or the other and log in before trying to publish.

Once the tools indicate that publishing is complete, your functions are up and running in Azure. The final output from the Core Tools will show the functions that were published, including the invocation URL of each function.

#### Things to know

Here are a few things to keep in mind when you use the Core Tools to publish your functions:

- The Core Tools do not validate or test your functions code during publishing. Make sure to use `func start` to do some testing before you publish!
- When you publish, any functions already present in the target app are stopped and deleted before the contents of your project are deployed. **You can't combine functions from multiple projects into one app by publishing them in sequence - all of the functions you want in the app must be in one project.**
- Publishing to Azure does not create any kind of relationship between the local project and the target function app. **You can publish a single functions project to multiple function apps.** You can also re-publish a project to the same app repeatedly as you work on your code.
- The invocation URLs displayed after you publish may include a `code` parameter in the query string, as in the screenshot above. By default, HTTP functions created by the Core Tools are configured with an authorization level of function, meaning they require callers to provide a secret key in the request headers or query string. The Core Tools includes the key in the query string of the displayed URL for your convenience.

## Exercise - Publish a function to Azure by using the Core Tools

## Summary
